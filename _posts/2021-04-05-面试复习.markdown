[TOC]

## 系统

### 虚拟内存

### 进程

#### 1.常见的进程间通讯方式
- 管道
- 信号量
- 共享内存（最快，但是解决同步问题，一般用信号量或者互斥锁解决）
- 消息队列

#### 2.僵尸进程和孤儿进程
**孤儿进程**

> 一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将会成为孤儿进程，由 `init` 进程对它们进行状态收集工作。

**僵尸进程**

> 一个进程通过 `fork` 创建子进程，子进程退出后，父进程没有调用 `wait` 或 `waitpid` 获取子进程状态，那么子进程的进程描述符会保留在系统中，这种进程称之为僵尸进程。


## 计算机网络

### TCP

#### TCP 和 UDP 有什么区别
- TCP 是面向连接的可靠传输协议，以字节流进行传输，受拥塞算法控制。
- UDP 是无连接的传输协议，以数据报为单位，不保证顺序。

#### UDP 如何实现可靠传输
  TCP 通过校验和、序号和确认应答、超时/差错重传以及其他优化措施（滑动窗口）实现。
  所以，UDP 可以通过一下方式实现可靠传输：
  1. 校验和，通过对数据部分进行哈希，然后将哈希算法类型和哈希结果在消息中发送给接收方。
  2. 序号和确认应答，加入消息序号保证顺序不会错乱，加入确认应答可以通知发送方哪些数据需要重传。
  3. 超时/差错重传，由于需要重传，所以发送方要把发送的数据放到缓存区，提高性能。
  4. 滑动窗口，除了控制发送速率，避免重复发送，以及接收方没有足够空间接受消息等问题。

#### 浏览器输入一个网址会发生什么，用到哪些协议
1. 域名解析，查找本地 hosts 文件是否有配置，没有就会去找 DNS 服务器解析。
2. 建立 TCP 连接。
3. 经由 IP 协议寻址和数据传输。
4. 发送 HTTP/HTTPS 请求。
5. 返回响应结果。
6. 关闭 TCP 连接。
7. 浏览器后续处理和渲染。

#### 四次挥手中，TIME-WAIT状态是在哪一步？

#### 三次握手过程第 **N** 条丢了会怎样？有什么现象？
1. 第一条 **SYN** 丢包：第一条客户端发出的 SYN 丢包的话，服务端根本感知不到该请求，所以主要由客户端处理，会有最多三次超时重传尝试。
2. 服务端收到 **SYN** 并回复的 **SYN,ACK** 包丢了：客户端会认为是第一条丢包了，所以客户端表现和第一条丢包流程一样。而对于服务端，此时处于 **SYN_RCVD** 状态，超时后未收到客户端发来的第三条 **SYN**，会进行数次重新发送 **SYN,ACK** 包（次数根据系统配置而异），重试超限后服务端会主动关闭这个连接。
3. 客户端最后一次回复 **SYN,ACK** 的 **ACK** 包丢了：客户端收到第二条后进入 `ESTABLISHED` 状态（认为连接已经建立），此时有两种情况，一是此时客户端开始发送数据，则服务端也会正常进入 `ESTABLISHED` 状态。另一种情况是，客户端此时没有发送数据，则服务端会超时重试，发送第二条 **SYN,ACK** 包，超限后关闭连接。

#### TIME-WAIT()状态下的等待时间是多少，为什么？
2MSL（Maximum Segment Lifetime）。该状态出现在主动关闭连接的一方发送完最后一次挥手，也就是 `ACK = 1` 的信号结束后，主动关闭连接方所处的状态。
这样设置的原因有两个：
1. 为了保证客户端发送的最后一个ack报文段能够到达服务器。
2. 在第四次挥手后，经过2msl的时间足以让本次连接产生的所有报文段都从网络中消失，这样下一次新的连接中就肯定不会出现旧连接的报文段了。

#### TCP流控制
TCP通过控制发送者发出的数据量来实现流控制，这一功能是通过滑动窗口机制来实现的。接受者的确认消息指明最后一次成功接收到报文段后可继续接收的报文段序号范围，这个可接收的序号范围称为窗口。
利用通知窗口进行流控制。

#### TCP 粘包、拆包，以及解决方案
TCP 之所以会出现粘包问题是因为它本身是面向连接的字节流传输协议，本身就没有包的概念，TCP 要发送的数据会被先放置在数据缓冲区，接收数据也是从缓冲区获取，而缓冲区的大小即为最大报文长度，如果需要发送的数据长度大于缓冲区剩余的大小或者大于最大报文长度，则会出现拆包，当要发送的数据很少，而短时间内又有其他数据包需要发送，就会出现粘包的现象。
解决方案一般有固定消息长度、设置标识符、在消息头指明消息长度。

### HTTP

#### HTTP 的 Keep-Alive
当使用 Keep-Alive 模式（又称持久连接、连接重用）时，Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。
Keep-Alive 有一下优点：
1. TCP连接更少，这样就会节约TCP连接在建立、释放过程中，主机和路由器上的CPU和内存开销。
2. 网络拥塞也减少了，拿到响应的延时也减少了。
3. 错误处理更优雅：不会粗暴地直接关闭连接，而是report，retry。

#### HTTP 与 HTTPS 有啥区别？说下 HTTPS 解决了什么问题，怎么解决的？
HTTPS 是 HTTP 的安全版本，通过加入 SSL/TCL 传输层安全协议，解决了 HTTP 的会话信息明文传输导致的安全问题（消息拦截、消息篡改、消息伪造）。

#### 说下 HTTPS 的握手过程
1. 建立安全能力
2. 服务端鉴别与密钥交换
3. 客户端鉴别与密钥交换
4. 客户端发送完成消息，服务端发送完成消息，握手完成

#### HTTPS 如何是如何保证安全的
通过消息加密防止窃听风险、通过校验机制防止篡改、通过身份证书防止冒充。

#### HTTP 优化方案
1. TCP 连接复用
2. HTTP 压缩
3. 缓存
4. CDN 缓存静态文件
5. 减少重定向，防止可能引入新的 DNS 查询、新的 TCP 连接以及新的 HTTP 请求

## 数据库

### MySQL

#### 行级锁、页级锁、表级锁
1. 行级锁：颗粒度最细，只针对当前操作的行加锁，发生锁冲突的概率最低，但是加锁开销大。有共享锁和排他锁两种。并发度最高，会出现死锁。
2. 表级锁：颗粒度最大，对全表进行加锁，发生冲突概率最高，但是实现简单，开销小。表级锁分为共享锁和排他锁两种。并发度最低，不会出现死锁。
3. 页级锁：属于行级和表级锁的折衷方案，一次锁定相邻的一组记录，各项指标处于行级锁和表级锁之间。会出现死锁。

#### 锁的优化策略
1. 减少锁的持有时间：对一个方法加锁，不如对方法中需要同步的几行代码加锁。
2. 降低锁的粒度：提高并发性。
3. 锁分离：根据同步操作的性质，把锁分为共享锁和排他锁，共享锁之间不互斥，提高了并发性。
4. 锁粗化：避免频繁加锁解锁，提高性能。
5. 锁消除：避免不必要的锁。

#### 什么是视图，游标是什么
视图：一种具有和物理表一样功能的虚拟表,由预设的查询语句定义好，使用时实时查询。视图通常是有一个表或者多个表的行或列的子集，对视图的修改会影响基本表，但是只有视图与表是一对一关系情况（还有其他条件，比如用了 `LIMIT` 就改不了）才能修改。

```SQL
-- 人物表
CREATE TABLE person (
id int4 NOT NULL PRIMARY KEY,
name varchar(32) NOT NULL
);
-- 初始化任务表数据
INSERT INTO person values(1, 'tom');
INSERT INTO person values(2, 'tony');
-- 食物表
CREATE TABLE food (
fid int4 NOT NULL PRIMARY KEY,
uid int4 NOT NULL,
name varchar(32) NOT NULL
);
-- 初始化食物表数据
INSERT INTO food values(1, 2, 'coffee');
INSERT INTO food values(2, 2, 'bread');
INSERT INTO food values(3, 1, 'honey');


-- 定义视图（不可修改）
DROP VIEW IF EXISTS `vuf` ;
CREATE ALGORITHM = UNDEFINED 
DEFINER = `root`@`localhost` 
SQL SECURITY DEFINER 
VIEW `vuf` AS (
SELECT f.uid, p.name, f.name AS favorite_food FROM 
food AS f
LEFT JOIN 
person AS p ON p.id = f.uid
ORDER BY f.uid ASC
);

-- 定义视图（可修改），但是在查询条件加上 LIMIT 的话也会禁止修改
DROP VIEW IF EXISTS `vu` ;
CREATE ALGORITHM = UNDEFINED 
DEFINER = `root`@`localhost` 
SQL SECURITY DEFINER 
VIEW `vuu` AS (
SELECT id, name FROM person WHERE id = 1
);
```

游标：一种能从包含多条结果集中提取其中一条进行处理的机制。

#### 什么是存储过程，用什么来调用
**存储过程**是一个预编译的 SQL 语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。
可以直接通过 `CALL` 关键字调用。
参数有 `IN`、 `OUT` 和 `INOUT` 三种，默认为 `IN`;
- IN：调用时指定，修改该参数的值不能被返回
- OUT：在存储过程内部被改变，并可返回，即该参数只是用来接收结果
- INOUT：调用时指定，并且可被改变和返回

```SQL
-- 先把把 // 定义为执行语法,CLI 中执行需要用到，不然会尝试执行定义函数里面的语句
DELIMITER // 
CREATE PROCEDURE showPersonById(targetId int) 
BEGIN 
	SELECT * FROM person WHERE id = targetId;
END
-- 还原执行符
DELIMITER ;
-- 调用
CALL showPersonById(1);
```

#### 视图和基本表的区别与联系
区别：
1. 视图是编译好的 SQL 语句，而基本表是实际的物理数据。
2. 基本表是内容，而视图是筛选器。
3. 表是内模式，视图是外模式。
4. 表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表，不会暴露真实的表结构。
5. 视图的建立和删除只影响视图本身（指的是整个 VIEW，而不是单独的记录），不影响对应的基本表。 

联系：视图是基于一个或多个基本表而建立的虚拟表，它的结构来自于定义，内容来自于基本表，是基本表在逻辑意义上建立的新关系。

#### 视图的优缺点
优点：
1. 简单，定义好以后可以多次调用。
2. 安全，不会暴露真实的表结构。
3. 独立，对于视图（整体而不是单条记录记录）的删除和创建不会影响基本表。

缺点：
1. 性能不好，简单的查询也会变得稍显复杂。
2. 修改不方便，复杂的聚合视图基本无法修改。

#### MySQL binlog 的格式
1. Statement 模式：记录每一条修改数据的 SQL，日志量少，节约磁盘IO，对一些特殊功能（NOW()、UUID() 等函数）的复制效果不是很好。
2. Row 模式：Row 模式下会记录下每一行数据被修改的细节，不会出现存储过程或触发器没有被复制的问题，但是如果批量操作太多日志量会很大。
3. Mixed 模式：实际上就是前两种模式的结合。在Mixed模式下，MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。

### 事务

#### 数据库的事务是什么
对数据进行更新的一个或多个操作组成的一个执行单元，其中的操作不可分割，要么都成功，要么都失败。事务具有原子性、一致性、隔离性和持久性。

#### 脏读、不可重复读和幻读分别指什么
脏读（Dirty Read）：事务一执行过程中修改了数据，此时事务二读取了修改后的数据，但是最终事务一没有成功提交，事务二读取到的就是脏数据。这种读取到另一个事务没有成功提交的数据称之为脏读。

不可重复读（Nonrepeatable Read）：事务二读取了两次数据，但是过程中事务一更改了数据，导致两次读取的数据不一致。这种在同一事务中，前后两次读取的数据不一致的现象就是不可重复读。

幻读（Phantom Read）：事务一前后两次读取同一范围的数据，但是两次读取过程中事务二增删了数据，导致两次读取的集合数量不一致，称为幻读。

#### MySQL 中 InnoDB 支持的四种事务隔离级别，以及各级别之间的区别
1. 读未提交（Read Uncommitted）：一个事务可以读取到另一事务修改但未提交的更新数据，即事务中修改即便没有提交，别的事务也可以看到。该隔离级别下会发生 **脏读**、**不可重复读**和**幻读**。

2. 读已提交（Read Committed）：事务中的修改只有提交后才能被其他事务看到。解决了**脏读**，但是还有**不可重复读**和**幻读**现象。

3. 可重复读（Repeated Read）：保证了同一事务先后执行的多次查询返回同一结果，看到的每行记录都是一致的，不受其他事务影响，这个级别存在**幻读**问题。

4. 串行化（Serializable）：强制事务串行化执行，读写互相阻塞，效率很低，最安全，不会出现**脏读**、**不可重复读**和**幻读**。

## 其他
