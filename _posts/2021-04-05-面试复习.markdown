[TOC]

## 系统

### 虚拟内存

### 进程

#### 1.常见的进程间通讯方式
- 管道
- 信号量
- 共享内存（最快，但是解决同步问题，一般用信号量或者互斥锁解决）
- 消息队列

#### 2.僵尸进程和孤儿进程
**孤儿进程**

> 一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将会成为孤儿进程，由 `init` 进程对它们进行状态收集工作。

**僵尸进程**

> 一个进程通过 `fork` 创建子进程，子进程退出后，父进程没有调用 `wait` 或 `waitpid` 获取子进程状态，那么子进程的进程描述符会保留在系统中，这种进程称之为僵尸进程。


## 计算机网络

### TCP

#### TCP 和 UDP 有什么区别
- TCP 是面向连接的可靠传输协议，以字节流进行传输，受拥塞算法控制。
- UDP 是无连接的传输协议，以数据报为单位，不保证顺序。

#### UDP 如何实现可靠传输
  TCP 通过校验和、序号和确认应答、超时/差错重传以及其他优化措施（滑动窗口）实现。
  所以，UDP 可以通过一下方式实现可靠传输：
  1. 校验和，通过对数据部分进行哈希，然后将哈希算法类型和哈希结果在消息中发送给接收方。
  2. 序号和确认应答，加入消息序号保证顺序不会错乱，加入确认应答可以通知发送方哪些数据需要重传。
  3. 超时/差错重传，由于需要重传，所以发送方要把发送的数据放到缓存区，提高性能。
  4. 滑动窗口，除了控制发送速率，避免重复发送，以及接收方没有足够空间接受消息等问题。

#### 浏览器输入一个网址会发生什么，用到哪些协议
1. 域名解析，查找本地 hosts 文件是否有配置，没有就会去找 DNS 服务器解析。
2. 建立 TCP 连接。
3. 经由 IP 协议寻址和数据传输。
4. 发送 HTTP/HTTPS 请求。
5. 返回响应结果。
6. 关闭 TCP 连接。
7. 浏览器后续处理和渲染。

#### 四次挥手中，TIME-WAIT状态是在哪一步？

#### 三次握手过程第 **N** 条丢了会怎样？有什么现象？
1. 第一条 **SYN** 丢包：第一条客户端发出的 SYN 丢包的话，服务端根本感知不到该请求，所以主要由客户端处理，会有最多三次超时重传尝试。
2. 服务端收到 **SYN** 并回复的 **SYN,ACK** 包丢了：客户端会认为是第一条丢包了，所以客户端表现和第一条丢包流程一样。而对于服务端，此时处于 **SYN_RCVD** 状态，超时后未收到客户端发来的第三条 **SYN**，会进行数次重新发送 **SYN,ACK** 包（次数根据系统配置而异），重试超限后服务端会主动关闭这个连接。
3. 客户端最后一次回复 **SYN,ACK** 的 **ACK** 包丢了：客户端收到第二条后进入 `ESTABLISHED` 状态（认为连接已经建立），此时有两种情况，一是此时客户端开始发送数据，则服务端也会正常进入 `ESTABLISHED` 状态。另一种情况是，客户端此时没有发送数据，则服务端会超时重试，发送第二条 **SYN,ACK** 包，超限后关闭连接。

#### TIME-WAIT()状态下的等待时间是多少，为什么？
2MSL（Maximum Segment Lifetime）。该状态出现在主动关闭连接的一方发送完最后一次挥手，也就是 `ACK = 1` 的信号结束后，主动关闭连接方所处的状态。
这样设置的原因有两个：
1. 为了保证客户端发送的最后一个ack报文段能够到达服务器。
2. 在第四次挥手后，经过2msl的时间足以让本次连接产生的所有报文段都从网络中消失，这样下一次新的连接中就肯定不会出现旧连接的报文段了。

#### TCP流控制
TCP通过控制发送者发出的数据量来实现流控制，这一功能是通过滑动窗口机制来实现的。接受者的确认消息指明最后一次成功接收到报文段后可继续接收的报文段序号范围，这个可接收的序号范围称为窗口。
利用通知窗口进行流控制。

#### TCP 粘包、拆包，以及解决方案
TCP 之所以会出现粘包问题是因为它本身是面向连接的字节流传输协议，本身就没有包的概念，TCP 要发送的数据会被先放置在数据缓冲区，接收数据也是从缓冲区获取，而缓冲区的大小即为最大报文长度，如果需要发送的数据长度大于缓冲区剩余的大小或者大于最大报文长度，则会出现拆包，当要发送的数据很少，而短时间内又有其他数据包需要发送，就会出现粘包的现象。
解决方案一般有固定消息长度、设置标识符、在消息头指明消息长度。

### HTTP

#### HTTP 的 Keep-Alive
当使用 Keep-Alive 模式（又称持久连接、连接重用）时，Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。
Keep-Alive 有一下优点：
1. TCP连接更少，这样就会节约TCP连接在建立、释放过程中，主机和路由器上的CPU和内存开销。
2. 网络拥塞也减少了，拿到响应的延时也减少了。
3. 错误处理更优雅：不会粗暴地直接关闭连接，而是report，retry。

#### HTTP 与 HTTPS 有啥区别？说下 HTTPS 解决了什么问题，怎么解决的？
HTTPS 是 HTTP 的安全版本，通过加入 SSL/TCL 传输层安全协议，解决了 HTTP 的会话信息明文传输导致的安全问题（消息拦截、消息篡改、消息伪造）。

#### 说下 HTTPS 的握手过程
1. 建立安全能力
2. 服务端鉴别与密钥交换
3. 客户端鉴别与密钥交换
4. 客户端发送完成消息，服务端发送完成消息，握手完成

#### HTTPS 如何是如何保证安全的
通过消息加密防止窃听风险、通过校验机制防止篡改、通过身份证书防止冒充。

#### HTTP 优化方案
1. TCP 连接复用
2. HTTP 压缩
3. 缓存
4. CDN 缓存静态文件
5. 减少重定向，防止可能引入新的 DNS 查询、新的 TCP 连接以及新的 HTTP 请求

## 数据库

### MySQL

#### 行级锁、页级锁、表级锁
1. 行级锁：颗粒度最细，只针对当前操作的行加锁，发生锁冲突的概率最低，但是加锁开销大。有共享锁和排他锁两种。并发度最高，会出现死锁。
2. 表级锁：颗粒度最大，对全表进行加锁，发生冲突概率最高，但是实现简单，开销小。表级锁分为共享锁和排他锁两种。并发度最低，不会出现死锁。
3. 页级锁：属于行级和表级锁的折衷方案，一次锁定相邻的一组记录，各项指标处于行级锁和表级锁之间。会出现死锁。

#### 锁的优化策略
1. 减少锁的持有时间：对一个方法加锁，不如对方法中需要同步的几行代码加锁。
2. 降低锁的粒度：提高并发性。
3. 锁分离：根据同步操作的性质，把锁分为共享锁和排他锁，共享锁之间不互斥，提高了并发性。
4. 锁粗化：避免频繁加锁解锁，提高性能。
5. 锁消除：避免不必要的锁。

#### 什么是视图，游标是什么
视图：一种具有和物理表一样功能的虚拟表,由预设的查询语句定义好，使用时实时查询。视图通常是有一个表或者多个表的行或列的子集，对视图的修改会影响基本表，但是只有视图与表是一对一关系情况（还有其他条件，比如用了 `LIMIT` 就改不了）才能修改。

```SQL
-- 人物表
CREATE TABLE person (
id int4 NOT NULL PRIMARY KEY,
name varchar(32) NOT NULL
);
-- 初始化任务表数据
INSERT INTO person values(1, 'tom');
INSERT INTO person values(2, 'tony');
-- 食物表
CREATE TABLE food (
fid int4 NOT NULL PRIMARY KEY,
uid int4 NOT NULL,
name varchar(32) NOT NULL
);
-- 初始化食物表数据
INSERT INTO food values(1, 2, 'coffee');
INSERT INTO food values(2, 2, 'bread');
INSERT INTO food values(3, 1, 'honey');


-- 定义视图（不可修改）
DROP VIEW IF EXISTS `vuf` ;
CREATE ALGORITHM = UNDEFINED 
DEFINER = `root`@`localhost` 
SQL SECURITY DEFINER 
VIEW `vuf` AS (
SELECT f.uid, p.name, f.name AS favorite_food FROM 
food AS f
LEFT JOIN 
person AS p ON p.id = f.uid
ORDER BY f.uid ASC
);

-- 定义视图（可修改），但是在查询条件加上 LIMIT 的话也会禁止修改
DROP VIEW IF EXISTS `vu` ;
CREATE ALGORITHM = UNDEFINED 
DEFINER = `root`@`localhost` 
SQL SECURITY DEFINER 
VIEW `vuu` AS (
SELECT id, name FROM person WHERE id = 1
);
```

游标：一种能从包含多条结果集中提取其中一条进行处理的机制。

#### 什么是存储过程，用什么来调用
**存储过程**是一个预编译的 SQL 语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。
可以直接通过 `CALL` 关键字调用。
参数有 `IN`、 `OUT` 和 `INOUT` 三种，默认为 `IN`;
- IN：调用时指定，修改该参数的值不能被返回
- OUT：在存储过程内部被改变，并可返回，即该参数只是用来接收结果
- INOUT：调用时指定，并且可被改变和返回

```SQL
-- 先把把 // 定义为执行语法,CLI 中执行需要用到，不然会尝试执行定义函数里面的语句
DELIMITER // 
CREATE PROCEDURE showPersonById(targetId int) 
BEGIN 
	SELECT * FROM person WHERE id = targetId;
END
-- 还原执行符
DELIMITER ;
-- 调用
CALL showPersonById(1);
```

#### 视图和基本表的区别与联系
区别：
1. 视图是编译好的 SQL 语句，而基本表是实际的物理数据。
2. 基本表是内容，而视图是筛选器。
3. 表是内模式，视图是外模式。
4. 表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表，不会暴露真实的表结构。
5. 视图的建立和删除只影响视图本身（指的是整个 VIEW，而不是单独的记录），不影响对应的基本表。 

联系：视图是基于一个或多个基本表而建立的虚拟表，它的结构来自于定义，内容来自于基本表，是基本表在逻辑意义上建立的新关系。

#### 视图的优缺点
优点：
1. 简单，定义好以后可以多次调用。
2. 安全，不会暴露真实的表结构。
3. 独立，对于视图（整体而不是单条记录记录）的删除和创建不会影响基本表。

缺点：
1. 性能不好，简单的查询也会变得稍显复杂。
2. 修改不方便，复杂的聚合视图基本无法修改。

#### MySQL binlog 的格式
1. Statement 模式：记录每一条修改数据的 SQL，日志量少，节约磁盘IO，对一些特殊功能（NOW()、UUID() 等函数）的复制效果不是很好。
2. Row 模式：Row 模式下会记录下每一行数据被修改的细节，不会出现存储过程或触发器没有被复制的问题，但是如果批量操作太多日志量会很大。
3. Mixed 模式：实际上就是前两种模式的结合。在Mixed模式下，MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。

### 事务

#### 数据库的事务是什么
对数据进行更新的一个或多个操作组成的一个执行单元，其中的操作不可分割，要么都成功，要么都失败。事务具有原子性、一致性、隔离性和持久性。

#### 脏读、不可重复读和幻读分别指什么
脏读（Dirty Read）：事务一执行过程中修改了数据，此时事务二读取了修改后的数据，但是最终事务一没有成功提交，事务二读取到的就是脏数据。这种读取到另一个事务没有成功提交的数据称之为脏读。

不可重复读（Nonrepeatable Read）：事务二读取了两次数据，但是过程中事务一更改了数据，导致两次读取的数据不一致。这种在同一事务中，前后两次读取的数据不一致的现象就是不可重复读。

幻读（Phantom Read）：事务一前后两次读取同一范围的数据，但是两次读取过程中事务二增删了数据，导致两次读取的集合数量不一致，称为幻读。

#### MySQL 中 InnoDB 支持的四种事务隔离级别，以及各级别之间的区别
1. 读未提交（Read Uncommitted）：一个事务可以读取到另一事务修改但未提交的更新数据，即事务中修改即便没有提交，别的事务也可以看到。该隔离级别下会发生 **脏读**、**不可重复读**和**幻读**。

2. 读已提交（Read Committed）：事务中的修改只有提交后才能被其他事务看到。解决了**脏读**，但是还有**不可重复读**和**幻读**现象。

3. 可重复读（Repeated Read）：保证了同一事务先后执行的多次查询返回同一结果，看到的每行记录都是一致的，不受其他事务影响，这个级别存在**幻读**问题。

4. 串行化（Serializable）：强制事务串行化执行，读写互相阻塞，效率很低，最安全，不会出现**脏读**、**不可重复读**和**幻读**。

#### MySQL 的事务回滚机制
MySQL 的 InnoDB 引擎通过 undo log 日志来实现事务回滚。当事务对数据进行修改时，InnoDB 会生成对应的 undo log，保存了事务发生之前的数据的一个版本，需要回滚时，利用其中的信息进行回滚操作。
undo log 属于逻辑日志，执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于 redo log 的。
当事务提交之后，undo log 并不能立马被删除， 而是放入待清理的链表，由 purge 线程判断是否由其他事务在使用 undo 段中表的上一个事务之前的版本信息，决定是否可以清理 undo log 的日志空间。


### 索引

ref: [MySQL常见面试题索引、表设计](https://www.cnblogs.com/open-yang/p/11417686.html)

#### 查看索引
```sql
SHOW INDEX FROM tableA;
```

#### 索引类型
1. 主键索引，特殊的唯一索引，不能为空。
2. 普通索引，使用单列作为索引，可以为空。
3. 唯一索引，索引列的值必须唯一，但允许为空。
4. 组合索引，在多个字段上建立的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会命中，使用组合索引时遵循最左前缀集合。
5. 全文索引，全文索引是对文本的内容进行分词，进行搜索。

#### B+ Tree 索引和 Hash 索引的区别
1. 如果是等值查询，Hash 索引有更好的查询效率。
2. 如果是范围查询或者排序，Hash 索引完全失效。
3. 哈希索引也不支持多列联合索引的最左匹配规则。
4. B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。

#### MySQL 中 B+ Tree 的叶子节点可以存哪些东西
InnoDb 的 B+ Tree 叶子节点存的可能是整行数据或者主键的值。储存了整行数据的是主键索引，也叫聚簇索引。而存储了主键的值的是非主键索引，也叫非聚簇索引。

#### 聚簇索引和非聚簇索引在查询数据的时候有区别吗
一般来说，利用聚簇索引查询一次就能得到数据，而非聚簇索引还要根据查到的主键值再次查询得到数据（回表）。但是有一种情况例外，就是覆盖索引，就是查询语句所用到的列的值只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。

#### 联合索引和最左前缀匹配
MySQL 的索引查询会遵循最左匹配原则，即最左优先，在检索数据时会从最左边开始匹配。所以当我们创建一个 (key1, key2, key3) 的联合索引时，相当与创建了 (key1)、(key1, key2)、(key1, key2, key3) 三个个索引。因此，创建联合索引时，一般会根据业务需求，将 `WHERE` 子句中最频繁的列放在最前面。

#### 什么情况下明明创建了索引，但是执行的时候并没有使用索引
查询优化器发现有更优的查询方案。在执行查询语句前，MySQL 的查询优化器会找出执行该语句的所有可能方案，对比之后找出成本最低的方案，即执行计划。如果全表扫描成本更低，就会放弃使用索引。
过程大致如下：
1. 根据搜索条件，找出所有可能使用的索引 
2. 计算全表扫描的代价 
3. 计算使用不同索引执行查询的代价 
4. 对比各种执行方案的代价，找出成本最低的那一个

#### 实际操作中，应该设置哪些字段作为索引
1. 主键、外键必须有索引。
2. 经常用来与其他表进行连接的表，用来连接的字段应该有索引。
3. 经常需要搜索查询、范围查询、或者排序的字段。
4. 业务上需要保持唯一性的字段。

#### 主键、外键和索引的区别
从作用来看：主键是每个表有且只有一个，用于保证数据的唯一性；外键用于建立两个表之间的连接，而且作为约束用来保证两个表之间数据一致性；索引用来加快数据检索和排序速度。
从关系来看：主键可以作为另一个表的外键，主键一定会有索引；外键一定会有外键索引；索引不一定是主键或外键。


### SQL 相关

#### SQL 语句优化方向
1. 精简查询字段，避免使用 `SELECT * FROM tableA`，读取字段内容也会消耗性能。
2. 优化索引，主要原则就是应尽量避免全表扫描，应该考虑在 `WHERE` 及 `ORDER BY` 涉及的列上建立索引。
3. 使用联合索引时，注意索引列的顺序。
4. 分页查询，加 `LIMIT` 防止查询数据量过大。
5. 优化查询语句，如：避免在 `WHERE` 子句中使用 `!=`；使用 `LIKE` 关键字最好固定左边以免索引失效；使用默认值代替 `NULL`，否则使用时 `IS NULL` 或者 `IS NOT NULL` 可能会全表扫描。
6. 限制索引数量，避免避免增加更新/插入时的系统开销。

#### CHAR 和 VARCHAR 的区别
1. char 的长度固定，而 varchar 的长度是不固定的，所以 char 的会占用更多空间，但是读取速度更快。
2. char 在取值的时候会把存值后面的空格去除掉，varchar 如果后面有空格则会保留；
3. 存储方式不一样，不同字符集的字符占用字节不一样。

#### 怎么找出最后一次插入时分配了哪个自动增量？
变量 `LAST_INSERT_ID` 将返回由 `auto_increment` 分配的最后一个值，并且不需要指定表名称。但是这个值会在 MySQL 重启重置为 0，所以不太准确。
> SHOW VARIABLES LIKE 'LAST_INSERT_ID';

#### BLOL 和 TEXT 有什么区别
`TEXT` 与 `BLOB` 的主要差别就是 `BLOB` 保存二进制数据，`TEXT` 保存字符数据，因此 `BLOB` 区分大小写，而 `TEXT` 不区分大小写。

```SQL
-- 建表
CREATE TABLE `person` (
  `id` int NOT NULL,
  `bl` blob,
  `te` text
)
-- 初始化数据
INSERT INTO person (id, bl, te) VALUES (1, 'abc', 'abc');
-- 查询
SELECT * FROM person WHERE bl = 'abc'; -- 1
SELECT * FROM person WHERE bl = 'ABC'; -- 0
SELECT * FROM person WHERE te = 'abc'; -- 1
SELECT * FROM person WHERE te = 'ABC'; -- 1
```

#### MySQL 怎么优化 DISTINCT？
ref: [DISTINCT Optimization](https://dev.mysql.com/doc/refman/8.0/en/distinct-optimization.html)

在大多数情况下，DISTINCT子句可以视为GROUP BY的特殊情况。例如，下面的两个查询是等效的：
```SQL
SELECT DISTINCT c1, c2, c3 FROM t1
WHERE c1 > const;

SELECT c1, c2, c3 FROM t1
WHERE c1 > const GROUP BY c1, c2, c3;
```
由于这个等效性，适用于 `GROUP BY` 查询的优化也可以被应用于有 `DISTINCT` 子句的查询。
所以改写成 `GROUP BY` 形式再优化。

#### 通用的 SQL 函数
SQL 的标准内置函数，不同的方言数据库基本都支持的。
常用的有：
1. 算术类：ABS()、MOD()、ROUND() 等。
2. 字符串类：CONCAT()、LENGTH()、LOWER()、UPPER() 等。
3. 日期类：CURRENT_DATE()、CURRENT_TIME()、CURRENT_TIMESTAMP() 等。
4. 转换类：CAST() 等

#### MySQL 有关权限的表有哪些
ref: [MySQL 用户权限管理](https://www.cnblogs.com/keme/p/10288168.html)

1. mysql.user 表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。
2. mysql.db 表：存放数据库级别的权限，记录哪些主机的哪些用户各个数据库上的操作权限。
3. mysql.tables_priv 表：存放表级别的权限，决定了来自哪些主机的哪些用户可以访问数据库的这个表。
4. mysql.columns_priv 表：存放列级别的权限，决定了来自哪些主机的哪些用户可以访问数据库表的这个字段
5. mysql.procs_priv 表：存放存储过程和函数级别的权限。

#### MySQL 外连接、内连接和自连接的区别
1. 外连接：筛选出两张表中匹配的数据，以及主表中未匹配的数据，即主表的所有数据都会被筛选出来。
2. 内连接：筛选出两张表中匹配的数据。
3. 自连接：针对相同的表进行的连接被称为“自连接”。

#### 完整性约束包括哪些？
数据完整性是指数据的精确性和可靠性。主要有四类：
1. 实体完整性：表的每一行数据是表中的唯一实体。
2. 域完整性；表中的列数据满足定义好的类型和取值范围。
3. 参照完整性：两个表的主键的值和外键的值保持一致，保证表之间的数据一致性。
4. 用户定义的完整性：用户根据需要制定的一些特殊约束（非空约束、唯一性约束等等）。

#### 如何确保表格里的字段只接受特定范围内的值？
在对应的列创建 `CHECK` 约束。


### Redis

#### Redis 的 hash 冲突是怎么解决的，rehash 的过程是怎么样的
ref: [美团针对Redis Rehash机制的探索和实践](https://tech.meituan.com/2018/07/27/redis-rehash-practice-optimization.html)

在Redis中，键值对（Key-Value Pair）存储方式是由字典（Dict）保存的，而字典底层是通过哈希表来实现的。Redis 通过链表（next 指针）来解决 hash 冲突。
Hash 冲突（负载因子）超过某个阈值时，出于链表性能的考虑，会进行 Resize 的操作。
Redis 使用了渐进式 rehash 机制，避免 rehash 对服务器性能造成影响，渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。

#### Redis 的持久化方式
ref: [Redis 持久化](https://www.redis.com.cn/redis-persistence.html)

Redis 提供了两种持久化的方式，分别是 RDB（Redis DataBase）和 AOF（Append Only File）。
RDB：将 Redis 某一时刻的数据持久化到磁盘中，是一种快照式的持久化方法。
AOF：将 Redis 执行过的所有写指令记录下来，在下次 Redis 重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了


## 其他
